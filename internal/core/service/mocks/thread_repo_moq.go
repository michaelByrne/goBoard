// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"goBoard/internal/core/domain"
	"goBoard/internal/core/ports"
	"sync"
	"time"
)

// Ensure, that ThreadRepoMock does implement ports.ThreadRepo.
// If this is not the case, regenerate this file with moq.
var _ ports.ThreadRepo = &ThreadRepoMock{}

// ThreadRepoMock is a mock implementation of ports.ThreadRepo.
//
//	func TestSomethingThatUsesThreadRepo(t *testing.T) {
//
//		// make and configure a mocked ports.ThreadRepo
//		mockedThreadRepo := &ThreadRepoMock{
//			GetPostByIDFunc: func(id int) (*domain.ThreadPost, error) {
//				panic("mock out the GetPostByID method")
//			},
//			GetThreadByIDFunc: func(id int, memberID int) (*domain.Thread, error) {
//				panic("mock out the GetThreadByID method")
//			},
//			ListPostsForThreadFunc: func(limit int, offset int, id int, memberID int) ([]domain.ThreadPost, error) {
//				panic("mock out the ListPostsForThread method")
//			},
//			ListPostsForThreadByCursorFunc: func(limit int, id int, cursor *time.Time) ([]domain.ThreadPost, error) {
//				panic("mock out the ListPostsForThreadByCursor method")
//			},
//			ListThreadsFunc: func(limit int, offset int) (*domain.SiteContext, error) {
//				panic("mock out the ListThreads method")
//			},
//			ListThreadsByCursorForwardFunc: func(limit int, cursor *time.Time, memberID int) ([]domain.Thread, error) {
//				panic("mock out the ListThreadsByCursorForward method")
//			},
//			ListThreadsByCursorReverseFunc: func(limit int, cursor *time.Time, memberID int) ([]domain.Thread, error) {
//				panic("mock out the ListThreadsByCursorReverse method")
//			},
//			ListThreadsByMemberIDFunc: func(memberID int, limit int, offset int) ([]domain.Thread, error) {
//				panic("mock out the ListThreadsByMemberID method")
//			},
//			PeekPreviousFunc: func(timestamp *time.Time) (bool, error) {
//				panic("mock out the PeekPrevious method")
//			},
//			SavePostFunc: func(post domain.ThreadPost) (int, error) {
//				panic("mock out the SavePost method")
//			},
//			SaveThreadFunc: func(thread domain.Thread) (int, error) {
//				panic("mock out the SaveThread method")
//			},
//			UndotThreadFunc: func(ctx context.Context, memberID int, threadID int) error {
//				panic("mock out the UndotThread method")
//			},
//		}
//
//		// use mockedThreadRepo in code that requires ports.ThreadRepo
//		// and then make assertions.
//
//	}
type ThreadRepoMock struct {
	// GetPostByIDFunc mocks the GetPostByID method.
	GetPostByIDFunc func(id int) (*domain.ThreadPost, error)

	// GetThreadByIDFunc mocks the GetThreadByID method.
	GetThreadByIDFunc func(id int, memberID int) (*domain.Thread, error)

	// ListPostsForThreadFunc mocks the ListPostsForThread method.
	ListPostsForThreadFunc func(limit int, offset int, id int, memberID int) ([]domain.ThreadPost, error)

	// ListPostsForThreadByCursorFunc mocks the ListPostsForThreadByCursor method.
	ListPostsForThreadByCursorFunc func(limit int, id int, cursor *time.Time) ([]domain.ThreadPost, error)

	// ListThreadsFunc mocks the ListThreads method.
	ListThreadsFunc func(limit int, offset int) (*domain.SiteContext, error)

	// ListThreadsByCursorForwardFunc mocks the ListThreadsByCursorForward method.
	ListThreadsByCursorForwardFunc func(limit int, cursor *time.Time, memberID int) ([]domain.Thread, error)

	// ListThreadsByCursorReverseFunc mocks the ListThreadsByCursorReverse method.
	ListThreadsByCursorReverseFunc func(limit int, cursor *time.Time, memberID int) ([]domain.Thread, error)

	// ListThreadsByMemberIDFunc mocks the ListThreadsByMemberID method.
	ListThreadsByMemberIDFunc func(memberID int, limit int, offset int) ([]domain.Thread, error)

	// PeekPreviousFunc mocks the PeekPrevious method.
	PeekPreviousFunc func(timestamp *time.Time) (bool, error)

	// SavePostFunc mocks the SavePost method.
	SavePostFunc func(post domain.ThreadPost) (int, error)

	// SaveThreadFunc mocks the SaveThread method.
	SaveThreadFunc func(thread domain.Thread) (int, error)

	// UndotThreadFunc mocks the UndotThread method.
	UndotThreadFunc func(ctx context.Context, memberID int, threadID int) error

	// calls tracks calls to the methods.
	calls struct {
		// GetPostByID holds details about calls to the GetPostByID method.
		GetPostByID []struct {
			// ID is the id argument value.
			ID int
		}
		// GetThreadByID holds details about calls to the GetThreadByID method.
		GetThreadByID []struct {
			// ID is the id argument value.
			ID int
			// MemberID is the memberID argument value.
			MemberID int
		}
		// ListPostsForThread holds details about calls to the ListPostsForThread method.
		ListPostsForThread []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
			// ID is the id argument value.
			ID int
			// MemberID is the memberID argument value.
			MemberID int
		}
		// ListPostsForThreadByCursor holds details about calls to the ListPostsForThreadByCursor method.
		ListPostsForThreadByCursor []struct {
			// Limit is the limit argument value.
			Limit int
			// ID is the id argument value.
			ID int
			// Cursor is the cursor argument value.
			Cursor *time.Time
		}
		// ListThreads holds details about calls to the ListThreads method.
		ListThreads []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// ListThreadsByCursorForward holds details about calls to the ListThreadsByCursorForward method.
		ListThreadsByCursorForward []struct {
			// Limit is the limit argument value.
			Limit int
			// Cursor is the cursor argument value.
			Cursor *time.Time
			// MemberID is the memberID argument value.
			MemberID int
		}
		// ListThreadsByCursorReverse holds details about calls to the ListThreadsByCursorReverse method.
		ListThreadsByCursorReverse []struct {
			// Limit is the limit argument value.
			Limit int
			// Cursor is the cursor argument value.
			Cursor *time.Time
			// MemberID is the memberID argument value.
			MemberID int
		}
		// ListThreadsByMemberID holds details about calls to the ListThreadsByMemberID method.
		ListThreadsByMemberID []struct {
			// MemberID is the memberID argument value.
			MemberID int
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// PeekPrevious holds details about calls to the PeekPrevious method.
		PeekPrevious []struct {
			// Timestamp is the timestamp argument value.
			Timestamp *time.Time
		}
		// SavePost holds details about calls to the SavePost method.
		SavePost []struct {
			// Post is the post argument value.
			Post domain.ThreadPost
		}
		// SaveThread holds details about calls to the SaveThread method.
		SaveThread []struct {
			// Thread is the thread argument value.
			Thread domain.Thread
		}
		// UndotThread holds details about calls to the UndotThread method.
		UndotThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// MemberID is the memberID argument value.
			MemberID int
			// ThreadID is the threadID argument value.
			ThreadID int
		}
	}
	lockGetPostByID                sync.RWMutex
	lockGetThreadByID              sync.RWMutex
	lockListPostsForThread         sync.RWMutex
	lockListPostsForThreadByCursor sync.RWMutex
	lockListThreads                sync.RWMutex
	lockListThreadsByCursorForward sync.RWMutex
	lockListThreadsByCursorReverse sync.RWMutex
	lockListThreadsByMemberID      sync.RWMutex
	lockPeekPrevious               sync.RWMutex
	lockSavePost                   sync.RWMutex
	lockSaveThread                 sync.RWMutex
	lockUndotThread                sync.RWMutex
}

// GetPostByID calls GetPostByIDFunc.
func (mock *ThreadRepoMock) GetPostByID(id int) (*domain.ThreadPost, error) {
	if mock.GetPostByIDFunc == nil {
		panic("ThreadRepoMock.GetPostByIDFunc: method is nil but ThreadRepo.GetPostByID was just called")
	}
	callInfo := struct {
		ID int
	}{
		ID: id,
	}
	mock.lockGetPostByID.Lock()
	mock.calls.GetPostByID = append(mock.calls.GetPostByID, callInfo)
	mock.lockGetPostByID.Unlock()
	return mock.GetPostByIDFunc(id)
}

// GetPostByIDCalls gets all the calls that were made to GetPostByID.
// Check the length with:
//
//	len(mockedThreadRepo.GetPostByIDCalls())
func (mock *ThreadRepoMock) GetPostByIDCalls() []struct {
	ID int
} {
	var calls []struct {
		ID int
	}
	mock.lockGetPostByID.RLock()
	calls = mock.calls.GetPostByID
	mock.lockGetPostByID.RUnlock()
	return calls
}

// GetThreadByID calls GetThreadByIDFunc.
func (mock *ThreadRepoMock) GetThreadByID(id int, memberID int) (*domain.Thread, error) {
	if mock.GetThreadByIDFunc == nil {
		panic("ThreadRepoMock.GetThreadByIDFunc: method is nil but ThreadRepo.GetThreadByID was just called")
	}
	callInfo := struct {
		ID       int
		MemberID int
	}{
		ID:       id,
		MemberID: memberID,
	}
	mock.lockGetThreadByID.Lock()
	mock.calls.GetThreadByID = append(mock.calls.GetThreadByID, callInfo)
	mock.lockGetThreadByID.Unlock()
	return mock.GetThreadByIDFunc(id, memberID)
}

// GetThreadByIDCalls gets all the calls that were made to GetThreadByID.
// Check the length with:
//
//	len(mockedThreadRepo.GetThreadByIDCalls())
func (mock *ThreadRepoMock) GetThreadByIDCalls() []struct {
	ID       int
	MemberID int
} {
	var calls []struct {
		ID       int
		MemberID int
	}
	mock.lockGetThreadByID.RLock()
	calls = mock.calls.GetThreadByID
	mock.lockGetThreadByID.RUnlock()
	return calls
}

// ListPostsForThread calls ListPostsForThreadFunc.
func (mock *ThreadRepoMock) ListPostsForThread(limit int, offset int, id int, memberID int) ([]domain.ThreadPost, error) {
	if mock.ListPostsForThreadFunc == nil {
		panic("ThreadRepoMock.ListPostsForThreadFunc: method is nil but ThreadRepo.ListPostsForThread was just called")
	}
	callInfo := struct {
		Limit    int
		Offset   int
		ID       int
		MemberID int
	}{
		Limit:    limit,
		Offset:   offset,
		ID:       id,
		MemberID: memberID,
	}
	mock.lockListPostsForThread.Lock()
	mock.calls.ListPostsForThread = append(mock.calls.ListPostsForThread, callInfo)
	mock.lockListPostsForThread.Unlock()
	return mock.ListPostsForThreadFunc(limit, offset, id, memberID)
}

// ListPostsForThreadCalls gets all the calls that were made to ListPostsForThread.
// Check the length with:
//
//	len(mockedThreadRepo.ListPostsForThreadCalls())
func (mock *ThreadRepoMock) ListPostsForThreadCalls() []struct {
	Limit    int
	Offset   int
	ID       int
	MemberID int
} {
	var calls []struct {
		Limit    int
		Offset   int
		ID       int
		MemberID int
	}
	mock.lockListPostsForThread.RLock()
	calls = mock.calls.ListPostsForThread
	mock.lockListPostsForThread.RUnlock()
	return calls
}

// ListPostsForThreadByCursor calls ListPostsForThreadByCursorFunc.
func (mock *ThreadRepoMock) ListPostsForThreadByCursor(limit int, id int, cursor *time.Time) ([]domain.ThreadPost, error) {
	if mock.ListPostsForThreadByCursorFunc == nil {
		panic("ThreadRepoMock.ListPostsForThreadByCursorFunc: method is nil but ThreadRepo.ListPostsForThreadByCursor was just called")
	}
	callInfo := struct {
		Limit  int
		ID     int
		Cursor *time.Time
	}{
		Limit:  limit,
		ID:     id,
		Cursor: cursor,
	}
	mock.lockListPostsForThreadByCursor.Lock()
	mock.calls.ListPostsForThreadByCursor = append(mock.calls.ListPostsForThreadByCursor, callInfo)
	mock.lockListPostsForThreadByCursor.Unlock()
	return mock.ListPostsForThreadByCursorFunc(limit, id, cursor)
}

// ListPostsForThreadByCursorCalls gets all the calls that were made to ListPostsForThreadByCursor.
// Check the length with:
//
//	len(mockedThreadRepo.ListPostsForThreadByCursorCalls())
func (mock *ThreadRepoMock) ListPostsForThreadByCursorCalls() []struct {
	Limit  int
	ID     int
	Cursor *time.Time
} {
	var calls []struct {
		Limit  int
		ID     int
		Cursor *time.Time
	}
	mock.lockListPostsForThreadByCursor.RLock()
	calls = mock.calls.ListPostsForThreadByCursor
	mock.lockListPostsForThreadByCursor.RUnlock()
	return calls
}

// ListThreads calls ListThreadsFunc.
func (mock *ThreadRepoMock) ListThreads(limit int, offset int) (*domain.SiteContext, error) {
	if mock.ListThreadsFunc == nil {
		panic("ThreadRepoMock.ListThreadsFunc: method is nil but ThreadRepo.ListThreads was just called")
	}
	callInfo := struct {
		Limit  int
		Offset int
	}{
		Limit:  limit,
		Offset: offset,
	}
	mock.lockListThreads.Lock()
	mock.calls.ListThreads = append(mock.calls.ListThreads, callInfo)
	mock.lockListThreads.Unlock()
	return mock.ListThreadsFunc(limit, offset)
}

// ListThreadsCalls gets all the calls that were made to ListThreads.
// Check the length with:
//
//	len(mockedThreadRepo.ListThreadsCalls())
func (mock *ThreadRepoMock) ListThreadsCalls() []struct {
	Limit  int
	Offset int
} {
	var calls []struct {
		Limit  int
		Offset int
	}
	mock.lockListThreads.RLock()
	calls = mock.calls.ListThreads
	mock.lockListThreads.RUnlock()
	return calls
}

// ListThreadsByCursorForward calls ListThreadsByCursorForwardFunc.
func (mock *ThreadRepoMock) ListThreadsByCursorForward(limit int, cursor *time.Time, memberID int) ([]domain.Thread, error) {
	if mock.ListThreadsByCursorForwardFunc == nil {
		panic("ThreadRepoMock.ListThreadsByCursorForwardFunc: method is nil but ThreadRepo.ListThreadsByCursorForward was just called")
	}
	callInfo := struct {
		Limit    int
		Cursor   *time.Time
		MemberID int
	}{
		Limit:    limit,
		Cursor:   cursor,
		MemberID: memberID,
	}
	mock.lockListThreadsByCursorForward.Lock()
	mock.calls.ListThreadsByCursorForward = append(mock.calls.ListThreadsByCursorForward, callInfo)
	mock.lockListThreadsByCursorForward.Unlock()
	return mock.ListThreadsByCursorForwardFunc(limit, cursor, memberID)
}

// ListThreadsByCursorForwardCalls gets all the calls that were made to ListThreadsByCursorForward.
// Check the length with:
//
//	len(mockedThreadRepo.ListThreadsByCursorForwardCalls())
func (mock *ThreadRepoMock) ListThreadsByCursorForwardCalls() []struct {
	Limit    int
	Cursor   *time.Time
	MemberID int
} {
	var calls []struct {
		Limit    int
		Cursor   *time.Time
		MemberID int
	}
	mock.lockListThreadsByCursorForward.RLock()
	calls = mock.calls.ListThreadsByCursorForward
	mock.lockListThreadsByCursorForward.RUnlock()
	return calls
}

// ListThreadsByCursorReverse calls ListThreadsByCursorReverseFunc.
func (mock *ThreadRepoMock) ListThreadsByCursorReverse(limit int, cursor *time.Time, memberID int) ([]domain.Thread, error) {
	if mock.ListThreadsByCursorReverseFunc == nil {
		panic("ThreadRepoMock.ListThreadsByCursorReverseFunc: method is nil but ThreadRepo.ListThreadsByCursorReverse was just called")
	}
	callInfo := struct {
		Limit    int
		Cursor   *time.Time
		MemberID int
	}{
		Limit:    limit,
		Cursor:   cursor,
		MemberID: memberID,
	}
	mock.lockListThreadsByCursorReverse.Lock()
	mock.calls.ListThreadsByCursorReverse = append(mock.calls.ListThreadsByCursorReverse, callInfo)
	mock.lockListThreadsByCursorReverse.Unlock()
	return mock.ListThreadsByCursorReverseFunc(limit, cursor, memberID)
}

// ListThreadsByCursorReverseCalls gets all the calls that were made to ListThreadsByCursorReverse.
// Check the length with:
//
//	len(mockedThreadRepo.ListThreadsByCursorReverseCalls())
func (mock *ThreadRepoMock) ListThreadsByCursorReverseCalls() []struct {
	Limit    int
	Cursor   *time.Time
	MemberID int
} {
	var calls []struct {
		Limit    int
		Cursor   *time.Time
		MemberID int
	}
	mock.lockListThreadsByCursorReverse.RLock()
	calls = mock.calls.ListThreadsByCursorReverse
	mock.lockListThreadsByCursorReverse.RUnlock()
	return calls
}

// ListThreadsByMemberID calls ListThreadsByMemberIDFunc.
func (mock *ThreadRepoMock) ListThreadsByMemberID(memberID int, limit int, offset int) ([]domain.Thread, error) {
	if mock.ListThreadsByMemberIDFunc == nil {
		panic("ThreadRepoMock.ListThreadsByMemberIDFunc: method is nil but ThreadRepo.ListThreadsByMemberID was just called")
	}
	callInfo := struct {
		MemberID int
		Limit    int
		Offset   int
	}{
		MemberID: memberID,
		Limit:    limit,
		Offset:   offset,
	}
	mock.lockListThreadsByMemberID.Lock()
	mock.calls.ListThreadsByMemberID = append(mock.calls.ListThreadsByMemberID, callInfo)
	mock.lockListThreadsByMemberID.Unlock()
	return mock.ListThreadsByMemberIDFunc(memberID, limit, offset)
}

// ListThreadsByMemberIDCalls gets all the calls that were made to ListThreadsByMemberID.
// Check the length with:
//
//	len(mockedThreadRepo.ListThreadsByMemberIDCalls())
func (mock *ThreadRepoMock) ListThreadsByMemberIDCalls() []struct {
	MemberID int
	Limit    int
	Offset   int
} {
	var calls []struct {
		MemberID int
		Limit    int
		Offset   int
	}
	mock.lockListThreadsByMemberID.RLock()
	calls = mock.calls.ListThreadsByMemberID
	mock.lockListThreadsByMemberID.RUnlock()
	return calls
}

// PeekPrevious calls PeekPreviousFunc.
func (mock *ThreadRepoMock) PeekPrevious(timestamp *time.Time) (bool, error) {
	if mock.PeekPreviousFunc == nil {
		panic("ThreadRepoMock.PeekPreviousFunc: method is nil but ThreadRepo.PeekPrevious was just called")
	}
	callInfo := struct {
		Timestamp *time.Time
	}{
		Timestamp: timestamp,
	}
	mock.lockPeekPrevious.Lock()
	mock.calls.PeekPrevious = append(mock.calls.PeekPrevious, callInfo)
	mock.lockPeekPrevious.Unlock()
	return mock.PeekPreviousFunc(timestamp)
}

// PeekPreviousCalls gets all the calls that were made to PeekPrevious.
// Check the length with:
//
//	len(mockedThreadRepo.PeekPreviousCalls())
func (mock *ThreadRepoMock) PeekPreviousCalls() []struct {
	Timestamp *time.Time
} {
	var calls []struct {
		Timestamp *time.Time
	}
	mock.lockPeekPrevious.RLock()
	calls = mock.calls.PeekPrevious
	mock.lockPeekPrevious.RUnlock()
	return calls
}

// SavePost calls SavePostFunc.
func (mock *ThreadRepoMock) SavePost(post domain.ThreadPost) (int, error) {
	if mock.SavePostFunc == nil {
		panic("ThreadRepoMock.SavePostFunc: method is nil but ThreadRepo.SavePost was just called")
	}
	callInfo := struct {
		Post domain.ThreadPost
	}{
		Post: post,
	}
	mock.lockSavePost.Lock()
	mock.calls.SavePost = append(mock.calls.SavePost, callInfo)
	mock.lockSavePost.Unlock()
	return mock.SavePostFunc(post)
}

// SavePostCalls gets all the calls that were made to SavePost.
// Check the length with:
//
//	len(mockedThreadRepo.SavePostCalls())
func (mock *ThreadRepoMock) SavePostCalls() []struct {
	Post domain.ThreadPost
} {
	var calls []struct {
		Post domain.ThreadPost
	}
	mock.lockSavePost.RLock()
	calls = mock.calls.SavePost
	mock.lockSavePost.RUnlock()
	return calls
}

// SaveThread calls SaveThreadFunc.
func (mock *ThreadRepoMock) SaveThread(thread domain.Thread) (int, error) {
	if mock.SaveThreadFunc == nil {
		panic("ThreadRepoMock.SaveThreadFunc: method is nil but ThreadRepo.SaveThread was just called")
	}
	callInfo := struct {
		Thread domain.Thread
	}{
		Thread: thread,
	}
	mock.lockSaveThread.Lock()
	mock.calls.SaveThread = append(mock.calls.SaveThread, callInfo)
	mock.lockSaveThread.Unlock()
	return mock.SaveThreadFunc(thread)
}

// SaveThreadCalls gets all the calls that were made to SaveThread.
// Check the length with:
//
//	len(mockedThreadRepo.SaveThreadCalls())
func (mock *ThreadRepoMock) SaveThreadCalls() []struct {
	Thread domain.Thread
} {
	var calls []struct {
		Thread domain.Thread
	}
	mock.lockSaveThread.RLock()
	calls = mock.calls.SaveThread
	mock.lockSaveThread.RUnlock()
	return calls
}

// UndotThread calls UndotThreadFunc.
func (mock *ThreadRepoMock) UndotThread(ctx context.Context, memberID int, threadID int) error {
	if mock.UndotThreadFunc == nil {
		panic("ThreadRepoMock.UndotThreadFunc: method is nil but ThreadRepo.UndotThread was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		MemberID int
		ThreadID int
	}{
		Ctx:      ctx,
		MemberID: memberID,
		ThreadID: threadID,
	}
	mock.lockUndotThread.Lock()
	mock.calls.UndotThread = append(mock.calls.UndotThread, callInfo)
	mock.lockUndotThread.Unlock()
	return mock.UndotThreadFunc(ctx, memberID, threadID)
}

// UndotThreadCalls gets all the calls that were made to UndotThread.
// Check the length with:
//
//	len(mockedThreadRepo.UndotThreadCalls())
func (mock *ThreadRepoMock) UndotThreadCalls() []struct {
	Ctx      context.Context
	MemberID int
	ThreadID int
} {
	var calls []struct {
		Ctx      context.Context
		MemberID int
		ThreadID int
	}
	mock.lockUndotThread.RLock()
	calls = mock.calls.UndotThread
	mock.lockUndotThread.RUnlock()
	return calls
}
