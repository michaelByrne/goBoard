// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"goBoard/internal/core/domain"
	"goBoard/internal/core/ports"
	"sync"
	"time"
)

// Ensure, that MessageRepoMock does implement ports.MessageRepo.
// If this is not the case, regenerate this file with moq.
var _ ports.MessageRepo = &MessageRepoMock{}

// MessageRepoMock is a mock implementation of ports.MessageRepo.
//
//	func TestSomethingThatUsesMessageRepo(t *testing.T) {
//
//		// make and configure a mocked ports.MessageRepo
//		mockedMessageRepo := &MessageRepoMock{
//			GetMessagePostByIDFunc: func(id int) (*domain.MessagePost, error) {
//				panic("mock out the GetMessagePostByID method")
//			},
//			GetMessagePostsByIDFunc: func(memberID int, messageID int, limit int) ([]domain.MessagePost, error) {
//				panic("mock out the GetMessagePostsByID method")
//			},
//			GetMessagesWithCursorForwardFunc: func(memberID int, limit int, cursor *time.Time) ([]domain.Message, error) {
//				panic("mock out the GetMessagesWithCursorForward method")
//			},
//			GetMessagesWithCursorReverseFunc: func(memberID int, limit int, cursor *time.Time) ([]domain.Message, error) {
//				panic("mock out the GetMessagesWithCursorReverse method")
//			},
//			PeekPreviousFunc: func(timestamp *time.Time) (bool, error) {
//				panic("mock out the PeekPrevious method")
//			},
//			SaveMessageFunc: func(message domain.Message) (int, error) {
//				panic("mock out the SaveMessage method")
//			},
//			SavePostFunc: func(post domain.MessagePost) (int, error) {
//				panic("mock out the SavePost method")
//			},
//		}
//
//		// use mockedMessageRepo in code that requires ports.MessageRepo
//		// and then make assertions.
//
//	}
type MessageRepoMock struct {
	// GetMessagePostByIDFunc mocks the GetMessagePostByID method.
	GetMessagePostByIDFunc func(id int) (*domain.MessagePost, error)

	// GetMessagePostsByIDFunc mocks the GetMessagePostsByID method.
	GetMessagePostsByIDFunc func(memberID int, messageID int, limit int) ([]domain.MessagePost, error)

	// GetMessagesWithCursorForwardFunc mocks the GetMessagesWithCursorForward method.
	GetMessagesWithCursorForwardFunc func(memberID int, limit int, cursor *time.Time) ([]domain.Message, error)

	// GetMessagesWithCursorReverseFunc mocks the GetMessagesWithCursorReverse method.
	GetMessagesWithCursorReverseFunc func(memberID int, limit int, cursor *time.Time) ([]domain.Message, error)

	// PeekPreviousFunc mocks the PeekPrevious method.
	PeekPreviousFunc func(timestamp *time.Time) (bool, error)

	// SaveMessageFunc mocks the SaveMessage method.
	SaveMessageFunc func(message domain.Message) (int, error)

	// SavePostFunc mocks the SavePost method.
	SavePostFunc func(post domain.MessagePost) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetMessagePostByID holds details about calls to the GetMessagePostByID method.
		GetMessagePostByID []struct {
			// ID is the id argument value.
			ID int
		}
		// GetMessagePostsByID holds details about calls to the GetMessagePostsByID method.
		GetMessagePostsByID []struct {
			// MemberID is the memberID argument value.
			MemberID int
			// MessageID is the messageID argument value.
			MessageID int
			// Limit is the limit argument value.
			Limit int
		}
		// GetMessagesWithCursorForward holds details about calls to the GetMessagesWithCursorForward method.
		GetMessagesWithCursorForward []struct {
			// MemberID is the memberID argument value.
			MemberID int
			// Limit is the limit argument value.
			Limit int
			// Cursor is the cursor argument value.
			Cursor *time.Time
		}
		// GetMessagesWithCursorReverse holds details about calls to the GetMessagesWithCursorReverse method.
		GetMessagesWithCursorReverse []struct {
			// MemberID is the memberID argument value.
			MemberID int
			// Limit is the limit argument value.
			Limit int
			// Cursor is the cursor argument value.
			Cursor *time.Time
		}
		// PeekPrevious holds details about calls to the PeekPrevious method.
		PeekPrevious []struct {
			// Timestamp is the timestamp argument value.
			Timestamp *time.Time
		}
		// SaveMessage holds details about calls to the SaveMessage method.
		SaveMessage []struct {
			// Message is the message argument value.
			Message domain.Message
		}
		// SavePost holds details about calls to the SavePost method.
		SavePost []struct {
			// Post is the post argument value.
			Post domain.MessagePost
		}
	}
	lockGetMessagePostByID           sync.RWMutex
	lockGetMessagePostsByID          sync.RWMutex
	lockGetMessagesWithCursorForward sync.RWMutex
	lockGetMessagesWithCursorReverse sync.RWMutex
	lockPeekPrevious                 sync.RWMutex
	lockSaveMessage                  sync.RWMutex
	lockSavePost                     sync.RWMutex
}

// GetMessagePostByID calls GetMessagePostByIDFunc.
func (mock *MessageRepoMock) GetMessagePostByID(id int) (*domain.MessagePost, error) {
	if mock.GetMessagePostByIDFunc == nil {
		panic("MessageRepoMock.GetMessagePostByIDFunc: method is nil but MessageRepo.GetMessagePostByID was just called")
	}
	callInfo := struct {
		ID int
	}{
		ID: id,
	}
	mock.lockGetMessagePostByID.Lock()
	mock.calls.GetMessagePostByID = append(mock.calls.GetMessagePostByID, callInfo)
	mock.lockGetMessagePostByID.Unlock()
	return mock.GetMessagePostByIDFunc(id)
}

// GetMessagePostByIDCalls gets all the calls that were made to GetMessagePostByID.
// Check the length with:
//
//	len(mockedMessageRepo.GetMessagePostByIDCalls())
func (mock *MessageRepoMock) GetMessagePostByIDCalls() []struct {
	ID int
} {
	var calls []struct {
		ID int
	}
	mock.lockGetMessagePostByID.RLock()
	calls = mock.calls.GetMessagePostByID
	mock.lockGetMessagePostByID.RUnlock()
	return calls
}

// GetMessagePostsByID calls GetMessagePostsByIDFunc.
func (mock *MessageRepoMock) GetMessagePostsByID(memberID int, messageID int, limit int) ([]domain.MessagePost, error) {
	if mock.GetMessagePostsByIDFunc == nil {
		panic("MessageRepoMock.GetMessagePostsByIDFunc: method is nil but MessageRepo.GetMessagePostsByID was just called")
	}
	callInfo := struct {
		MemberID  int
		MessageID int
		Limit     int
	}{
		MemberID:  memberID,
		MessageID: messageID,
		Limit:     limit,
	}
	mock.lockGetMessagePostsByID.Lock()
	mock.calls.GetMessagePostsByID = append(mock.calls.GetMessagePostsByID, callInfo)
	mock.lockGetMessagePostsByID.Unlock()
	return mock.GetMessagePostsByIDFunc(memberID, messageID, limit)
}

// GetMessagePostsByIDCalls gets all the calls that were made to GetMessagePostsByID.
// Check the length with:
//
//	len(mockedMessageRepo.GetMessagePostsByIDCalls())
func (mock *MessageRepoMock) GetMessagePostsByIDCalls() []struct {
	MemberID  int
	MessageID int
	Limit     int
} {
	var calls []struct {
		MemberID  int
		MessageID int
		Limit     int
	}
	mock.lockGetMessagePostsByID.RLock()
	calls = mock.calls.GetMessagePostsByID
	mock.lockGetMessagePostsByID.RUnlock()
	return calls
}

// GetMessagesWithCursorForward calls GetMessagesWithCursorForwardFunc.
func (mock *MessageRepoMock) GetMessagesWithCursorForward(memberID int, limit int, cursor *time.Time) ([]domain.Message, error) {
	if mock.GetMessagesWithCursorForwardFunc == nil {
		panic("MessageRepoMock.GetMessagesWithCursorForwardFunc: method is nil but MessageRepo.GetMessagesWithCursorForward was just called")
	}
	callInfo := struct {
		MemberID int
		Limit    int
		Cursor   *time.Time
	}{
		MemberID: memberID,
		Limit:    limit,
		Cursor:   cursor,
	}
	mock.lockGetMessagesWithCursorForward.Lock()
	mock.calls.GetMessagesWithCursorForward = append(mock.calls.GetMessagesWithCursorForward, callInfo)
	mock.lockGetMessagesWithCursorForward.Unlock()
	return mock.GetMessagesWithCursorForwardFunc(memberID, limit, cursor)
}

// GetMessagesWithCursorForwardCalls gets all the calls that were made to GetMessagesWithCursorForward.
// Check the length with:
//
//	len(mockedMessageRepo.GetMessagesWithCursorForwardCalls())
func (mock *MessageRepoMock) GetMessagesWithCursorForwardCalls() []struct {
	MemberID int
	Limit    int
	Cursor   *time.Time
} {
	var calls []struct {
		MemberID int
		Limit    int
		Cursor   *time.Time
	}
	mock.lockGetMessagesWithCursorForward.RLock()
	calls = mock.calls.GetMessagesWithCursorForward
	mock.lockGetMessagesWithCursorForward.RUnlock()
	return calls
}

// GetMessagesWithCursorReverse calls GetMessagesWithCursorReverseFunc.
func (mock *MessageRepoMock) GetMessagesWithCursorReverse(memberID int, limit int, cursor *time.Time) ([]domain.Message, error) {
	if mock.GetMessagesWithCursorReverseFunc == nil {
		panic("MessageRepoMock.GetMessagesWithCursorReverseFunc: method is nil but MessageRepo.GetMessagesWithCursorReverse was just called")
	}
	callInfo := struct {
		MemberID int
		Limit    int
		Cursor   *time.Time
	}{
		MemberID: memberID,
		Limit:    limit,
		Cursor:   cursor,
	}
	mock.lockGetMessagesWithCursorReverse.Lock()
	mock.calls.GetMessagesWithCursorReverse = append(mock.calls.GetMessagesWithCursorReverse, callInfo)
	mock.lockGetMessagesWithCursorReverse.Unlock()
	return mock.GetMessagesWithCursorReverseFunc(memberID, limit, cursor)
}

// GetMessagesWithCursorReverseCalls gets all the calls that were made to GetMessagesWithCursorReverse.
// Check the length with:
//
//	len(mockedMessageRepo.GetMessagesWithCursorReverseCalls())
func (mock *MessageRepoMock) GetMessagesWithCursorReverseCalls() []struct {
	MemberID int
	Limit    int
	Cursor   *time.Time
} {
	var calls []struct {
		MemberID int
		Limit    int
		Cursor   *time.Time
	}
	mock.lockGetMessagesWithCursorReverse.RLock()
	calls = mock.calls.GetMessagesWithCursorReverse
	mock.lockGetMessagesWithCursorReverse.RUnlock()
	return calls
}

// PeekPrevious calls PeekPreviousFunc.
func (mock *MessageRepoMock) PeekPrevious(timestamp *time.Time) (bool, error) {
	if mock.PeekPreviousFunc == nil {
		panic("MessageRepoMock.PeekPreviousFunc: method is nil but MessageRepo.PeekPrevious was just called")
	}
	callInfo := struct {
		Timestamp *time.Time
	}{
		Timestamp: timestamp,
	}
	mock.lockPeekPrevious.Lock()
	mock.calls.PeekPrevious = append(mock.calls.PeekPrevious, callInfo)
	mock.lockPeekPrevious.Unlock()
	return mock.PeekPreviousFunc(timestamp)
}

// PeekPreviousCalls gets all the calls that were made to PeekPrevious.
// Check the length with:
//
//	len(mockedMessageRepo.PeekPreviousCalls())
func (mock *MessageRepoMock) PeekPreviousCalls() []struct {
	Timestamp *time.Time
} {
	var calls []struct {
		Timestamp *time.Time
	}
	mock.lockPeekPrevious.RLock()
	calls = mock.calls.PeekPrevious
	mock.lockPeekPrevious.RUnlock()
	return calls
}

// SaveMessage calls SaveMessageFunc.
func (mock *MessageRepoMock) SaveMessage(message domain.Message) (int, error) {
	if mock.SaveMessageFunc == nil {
		panic("MessageRepoMock.SaveMessageFunc: method is nil but MessageRepo.SaveMessage was just called")
	}
	callInfo := struct {
		Message domain.Message
	}{
		Message: message,
	}
	mock.lockSaveMessage.Lock()
	mock.calls.SaveMessage = append(mock.calls.SaveMessage, callInfo)
	mock.lockSaveMessage.Unlock()
	return mock.SaveMessageFunc(message)
}

// SaveMessageCalls gets all the calls that were made to SaveMessage.
// Check the length with:
//
//	len(mockedMessageRepo.SaveMessageCalls())
func (mock *MessageRepoMock) SaveMessageCalls() []struct {
	Message domain.Message
} {
	var calls []struct {
		Message domain.Message
	}
	mock.lockSaveMessage.RLock()
	calls = mock.calls.SaveMessage
	mock.lockSaveMessage.RUnlock()
	return calls
}

// SavePost calls SavePostFunc.
func (mock *MessageRepoMock) SavePost(post domain.MessagePost) (int, error) {
	if mock.SavePostFunc == nil {
		panic("MessageRepoMock.SavePostFunc: method is nil but MessageRepo.SavePost was just called")
	}
	callInfo := struct {
		Post domain.MessagePost
	}{
		Post: post,
	}
	mock.lockSavePost.Lock()
	mock.calls.SavePost = append(mock.calls.SavePost, callInfo)
	mock.lockSavePost.Unlock()
	return mock.SavePostFunc(post)
}

// SavePostCalls gets all the calls that were made to SavePost.
// Check the length with:
//
//	len(mockedMessageRepo.SavePostCalls())
func (mock *MessageRepoMock) SavePostCalls() []struct {
	Post domain.MessagePost
} {
	var calls []struct {
		Post domain.MessagePost
	}
	mock.lockSavePost.RLock()
	calls = mock.calls.SavePost
	mock.lockSavePost.RUnlock()
	return calls
}
